MODULE NPC0;

IMPORT EnvLayer;


CONST

  NewLine = 0AH;
  MaxInt = 7FFFFFFFH; MinInt = -MaxInt - 1;
  MaxLenInt = 11;
  MaxLenIdent = 32;

  TokIdentifier = -1; TokInt = -2; TokChar = -3;

  TokDo = 1; TokIf = 2; TokOf = 3; TokOr = 4; TokDiv = 5; TokEnd = 6;
  TokMod = 7; TokVar = 8; TokElse = 9; TokThen = 10; TokType = 11;
  TokArray = 12; TokBegin = 13; TokConst = 14; TokElsif = 15;
  TokWhile = 16; TokModule = 17; TokRecord = 18; TokProcedure = 19;
  NbrKeywords = 20;

  TokAmper = 30; TokAssign = 31; TokAsterisk = 32; TokBraceL = 33;
  TokBraceR = 34; TokBrackL = 35; TokBrackR = 36; TokColon = 37;
  TokComma = 38; TokDot = 39; TokMinus = 40; TokParenL = 41;
  TokParenR = 42; TokPercent = 43; TokPlus = 44; TokSemic = 45;
  TokSlash = 46; TokTilde = 47; TokEq = 48; TokEqN = 49; TokLss = 50;
  TokLEq = 51; TokGtr = 52; TokGEq = 53;

  ErrUnexpEof = MinInt + 1;
  ErrUnexpEofInComment = MinInt + 2;
  ErrIdentTooLong = MinInt + 3;
  ErrIntTooLong = MinInt + 4;
  ErrPostfixH = MinInt + 5;
  ErrIntOverflow = MinInt + 6;
  ErrCharOverflow = MinInt + 7;


TYPE

  Keyword = ARRAY 12 OF CHAR;

  Ident = RECORD
    data : ARRAY MaxLenIdent OF CHAR;
    len : INTEGER
  END;

  Source = RECORD
    line : INTEGER;
    pos : INTEGER;
    char : INTEGER;
    token : INTEGER;
    ident : Ident;
    value : INTEGER
  END;


VAR

  envParam : INTEGER;
  code : ARRAY 10 OF INTEGER;

  keywordLens : ARRAY 10 OF INTEGER;
  keywords : ARRAY NbrKeywords OF Keyword;

  source : Source;


(* sys calls *)


PROCEDURE SysCall(nr : INTEGER);

  BEGIN
    IF nr = -1 THEN
      EnvLayer.Exit(envParam)
    ELSIF nr = -2 THEN
      EnvLayer.GetChar(envParam)
    ELSIF nr = -3 THEN
      EnvLayer.PutChar(envParam)
    ELSIF nr = -4 THEN
      EnvLayer.WriteFile(code)
    END
  END SysCall;


(* print procedures *)


PROCEDURE PrintChar(char : INTEGER);

  BEGIN
    envParam := char;
    SysCall(-3)
  END PrintChar;


PROCEDURE PrintChars(chars : INTEGER);

  BEGIN
    IF chars > 0 THEN
      PrintChars(chars DIV 256);
      PrintChar(chars MOD 256)
    END
  END PrintChars;


PROCEDURE PrintInt(int : INTEGER);

  VAR
    i : INTEGER;
    tmpBuf : ARRAY MaxLenInt + 1 OF CHAR;

  BEGIN
    i := 0;
    IF int = MinInt THEN
      (* -2147483648 *)
      PrintChars(2D323134H);
      PrintChars(37343833H);
      PrintChars(363438H);
      int := 0
    ELSIF int < 0 THEN
      PrintChar(2DH (*-*));
      int := -int
    ELSIF int = 0 THEN
      tmpBuf[0] := 30X (*0*);
      i := i + 1
    END;
    WHILE int # 0 DO
      tmpBuf[i] := CHR(30H + int MOD 10);
      i := i + 1;
      int := int DIV 10
    END;
    WHILE i > 0 DO
      i := i - 1;
      PrintChar(ORD(tmpBuf[i]))
    END
  END PrintInt;


PROCEDURE PrintKeyword(token : INTEGER);

  VAR kwLen : INTEGER;

  PROCEDURE print(VAR kw : Keyword; len : INTEGER);

    VAR ix : INTEGER;

    BEGIN
      ix := 0;
      WHILE ix < len DO
        PrintChar(ORD(kw[ix]));
        ix := ix + 1
      END
    END print;

  BEGIN (* PrintKeyword *)
    kwLen := 0;
    WHILE keywordLens[kwLen] < token DO
      kwLen := kwLen + 1
    END;
    print(keywords[token], kwLen)
  END PrintKeyword;


(* scanner *)


PROCEDURE ScannerInitialize;

  PROCEDURE enterKW(token : INTEGER;
                    chars1, chars2, chars3 : INTEGER);

    PROCEDURE enterChars(VAR kw : Keyword;
                         ix : INTEGER;
                         chars : INTEGER);
      BEGIN
        IF chars > 0 THEN
          enterChars(kw, ix + 1, chars DIV 256);
          kw[ix] := CHR(chars MOD 256)
        END
      END enterChars;

    BEGIN (* enterKW *)
      enterChars(keywords[token], 0, chars1);
      enterChars(keywords[token], 4, chars2);
      enterChars(keywords[token], 8, chars3)
    END enterKW;

  BEGIN (* ScannerInitialize *)
    keywordLens[0] := 0;
    keywordLens[1] := 0;
    enterKW(TokDo, 4F44H, 0, 0);
    enterKW(TokIf, 4649H, 0, 0);
    enterKW(TokOf, 464FH, 0, 0);
    enterKW(TokOr, 524FH, 0, 0);
    keywordLens[2] := TokOr;
    enterKW(TokDiv, 564944H, 0, 0);
    enterKW(TokEnd, 444E45H, 0, 0);
    enterKW(TokMod, 444F4DH, 0, 0);
    enterKW(TokVar, 524156H, 0, 0);
    keywordLens[3] := TokVar;
    enterKW(TokElse, 45534C45H, 0, 0);
    enterKW(TokThen, 4E454854H, 0, 0);
    enterKW(TokType, 45505954H, 0, 0);
    keywordLens[4] := TokType;
    enterKW(TokArray, 41525241H, 59H, 0);
    enterKW(TokBegin, 49474542H, 4EH, 0);
    enterKW(TokConst, 534E4F43H, 54H, 0);
    enterKW(TokElsif, 49534C45H, 46H, 0);
    enterKW(TokWhile, 4C494857H, 45H, 0);
    keywordLens[5] := TokWhile;
    enterKW(TokModule, 55444F4DH, 454CH, 0);
    enterKW(TokRecord, 4F434552H, 4452H, 0);
    keywordLens[6] := TokRecord;
    keywordLens[7] := TokRecord;
    keywordLens[8] := TokRecord;
    enterKW(TokProcedure, 434F5250H, 52554445H, 45H);
    keywordLens[9] := TokProcedure;
    source.line := 0;
    source.char := NewLine
  END ScannerInitialize;


PROCEDURE ScannerRaiseError(errorNr : INTEGER);

  BEGIN
    PrintChar(NewLine);
    PrintChar(NewLine);
    PrintChars(45525220H);
    PrintInt(source.line);
    PrintChar(2FH);
    PrintInt(source.pos);
    PrintChars(3A20H);
    IF errorNr < MinInt + 256 THEN
      PrintInt(errorNr - MinInt)
    ELSE (* errorNr contains expected token *)
      PrintKeyword(errorNr);
      PrintChars(203FH)
    END;
    PrintChar(NewLine);
    envParam := errorNr; SysCall(-1)
  END ScannerRaiseError;


PROCEDURE ScannerReadChar;

  BEGIN
    IF source.char = NewLine THEN
      source.line := source.line + 1;
      source.pos := 1
    ELSE
      source.pos := source.pos + 1
    END;
    SysCall(-2); source.char := envParam;
    IF source.char = -1 THEN
      ScannerRaiseError(ErrUnexpEof)
    END
  END ScannerReadChar;


PROCEDURE ScannerNext;


  PROCEDURE comment;

    VAR repeat : BOOLEAN;

    BEGIN
      ScannerReadChar;
      repeat := TRUE;
      WHILE repeat DO
        IF source.char = 28H (* ( *) THEN
          ScannerReadChar;
          IF source.char = 2AH (* * *) THEN
            comment
          END
        ELSIF source.char = 2AH (* * *) THEN
          ScannerReadChar;
          IF source.char = 29H (* ) *) THEN
            repeat := FALSE;
            ScannerReadChar;
          END
        ELSE
          ScannerReadChar;
        END
      END
    END comment;


  PROCEDURE identifier;

    VAR repeat : BOOLEAN; i, k : INTEGER;

    BEGIN
      source.ident.len := 0;
      repeat := TRUE;
      WHILE repeat DO
        IF source.ident.len < MaxLenIdent THEN
          source.ident.data[source.ident.len] := CHR(source.char);
          source.ident.len := source.ident.len + 1;
          ScannerReadChar;
          repeat :=
            (source.char >= 30H) & (source.char <= 39H) OR
            (source.char >= 41H) & (source.char <= 5AH) OR
            (source.char >= 61H) & (source.char <= 7AH);
        ELSE
          ScannerRaiseError(ErrIdentTooLong)
        END
      END;
      source.token := TokIdentifier;
      IF source.ident.len <= 9 (* biggest keyword PROCEDURE *) THEN
        k := keywordLens[source.ident.len - 1] + 1;
        WHILE k <= keywordLens[source.ident.len] DO
          i := 0;
          WHILE i < source.ident.len DO
            IF source.ident.data[i] # keywords[k][i] THEN
              i := MaxInt
            ELSE
              i := i + 1
            END
          END;
          IF i = source.ident.len THEN
            source.token := k;
            k := MaxInt
          ELSE
            k := k + 1
          END
        END
      END
    END identifier;


  PROCEDURE number;

    VAR

      buf : ARRAY MaxLenInt OF CHAR;
      bufIx, bufIx2 : INTEGER;
      hex : BOOLEAN; base : INTEGER;
      n : INTEGER; c : CHAR;
      max, maxMod : INTEGER;

    BEGIN
      bufIx := 0;
      hex := TRUE;
      base := 10;
      WHILE hex OR (source.char >= 30H) & (source.char <= 39H) DO
        IF bufIx < MaxLenInt THEN
          buf[bufIx] := CHR(source.char);
          bufIx := bufIx + 1;
          ScannerReadChar;
          hex := (source.char >= 41H) & (source.char <= 46H);
          IF hex THEN base := 16 END
        ELSE
          ScannerRaiseError(ErrIntTooLong)
        END
      END;
      source.token := TokInt;
      IF source.char = 48H THEN
        base := 16;
        ScannerReadChar
      ELSIF source.char = 58H THEN
        base := 16;
        ScannerReadChar;
        source.token := TokChar
      ELSIF base = 16 THEN
        ScannerRaiseError(ErrPostfixH)
      END;
      bufIx2 := 0;
      source.value := 0;
      max := MaxInt DIV base;
      maxMod := MaxInt MOD base;
      WHILE bufIx2 < bufIx DO
        c := buf[bufIx2];
        bufIx2 := bufIx2 + 1;
        IF (c >= 41X) & (c <= 46X) THEN
          n := 10 - 41H + ORD(c)
        ELSE
          n := - 30H + ORD(c)
        END;
        IF (source.value < max) OR (n <= maxMod) THEN
          source.value := base * source.value + n
        ELSE
          ScannerRaiseError(ErrIntOverflow)
        END
      END;
      IF (source.token = TokChar) & (source.value > 255) THEN
        ScannerRaiseError(ErrCharOverflow)
      END
    END number;


  BEGIN (* ScannerNext *)
    source.token := 0;
    WHILE source.token = 0 DO
      IF source.char <= 20H THEN
        ScannerReadChar
      ELSIF source.char < 41H (* A *) THEN
        IF source.char < 30H (* 0 *) THEN
          IF source.char = 23H (* # *) THEN
            source.token := TokEqN; ScannerReadChar
          ELSIF source.char = 26H (* & *) THEN
            source.token := TokAmper; ScannerReadChar
          ELSIF source.char = 28H (* ( *) THEN
            source.token := TokParenL; ScannerReadChar;
            IF source.char = 2AH (* * *) THEN
              comment; source.token := 0
            END
          ELSIF source.char = 29H (* ) *) THEN
            source.token := TokParenR; ScannerReadChar
          ELSIF source.char = 2AH (* * *) THEN
            source.token := TokAsterisk; ScannerReadChar
          ELSIF source.char = 2BH (* + *) THEN
            source.token := TokPlus; ScannerReadChar
          ELSIF source.char = 2CH (* , *) THEN
            source.token := TokComma; ScannerReadChar
          ELSIF source.char = 2DH (* - *) THEN
            source.token := TokMinus; ScannerReadChar
          ELSIF source.char = 2EH (* . *) THEN
            source.token := TokDot; ScannerReadChar
          ELSIF source.char = 2FH (* / *) THEN
            source.token := TokSlash; ScannerReadChar
          ELSE (* ! $ % ' *)
            ScannerReadChar
          END
        ELSIF source.char < 3AH (* : *) THEN
          number
        ELSIF source.char = 3AH (* : *) THEN
          source.token := TokColon; ScannerReadChar;
          IF source.char = 3DH (* = *) THEN
            source.token := TokAssign; ScannerReadChar
          END
        ELSIF source.char = 3BH (* ; *) THEN
          source.token := TokSemic; ScannerReadChar
        ELSIF source.char = 3CH (* < *) THEN
          source.token := TokLss; ScannerReadChar;
          IF source.char = 3DH (* = *) THEN
            source.token := TokLEq; ScannerReadChar
          END
        ELSIF source.char = 3DH (* = *) THEN
          source.token := TokEq; ScannerReadChar
        ELSIF source.char = 3EH (* > *) THEN
          source.token := TokGtr; ScannerReadChar;
          IF source.char = 3DH (* = *) THEN
            source.token := TokGEq; ScannerReadChar
          END
        ELSE (* ? @ *)
          ScannerReadChar
        END
      ELSIF source.char < 5BH (* [ *) THEN
        identifier
      ELSIF source.char < 61H (* a *) THEN
        IF source.char = 5BH (* [ *) THEN
          source.token := TokBrackL; ScannerReadChar
        ELSIF source.char = 5DH (* ] *) THEN
          source.token := TokBrackR; ScannerReadChar
        ELSE (* ^ _ ` *)
          ScannerReadChar
        END
      ELSIF source.char < 7BH (* { *) THEN
        identifier
      ELSE
        IF source.char = 7BH (* { *) THEN
          source.token := TokBraceL; ScannerReadChar
        ELSIF source.char = 7DH (* } *) THEN
          source.token := TokBraceR; ScannerReadChar
        ELSIF source.char = 7EH (* ~ *) THEN
          source.token := TokTilde; ScannerReadChar
        ELSE (* | >7E *)
          ScannerReadChar
        END
      END
    END
  END ScannerNext;


BEGIN
  ScannerInitialize; ScannerReadChar;
  ScannerNext;
  WHILE TRUE DO
    PrintInt(source.line);
    PrintChar(2FH);
    PrintInt(source.pos);
    PrintChar(20H);
    PrintInt(source.token);
    IF source.token = TokInt THEN
      PrintChar(20H);
      PrintInt(source.value)
    END;
    PrintChar(NewLine);
    ScannerNext
  END
END NPC0.
