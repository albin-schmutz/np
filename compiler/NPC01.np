MODULE NPC01;

IMPORT Sys, Buf, Base := NPC01B, Scanner := NPC01S, STable := NPC01Y;


CONST

  ModeReg = 10; ModeCond = 11;

  RegGP = 11; (* global pointer *)
  RegFP = 12; (* frame pointer *)
  RegSP = 13; (* stack pointer *)
  RegRT = 14; (* return register *)
  RegPC = 15; (* program counter *)

  OcMOV = 8; OcMVN = 9; OcCMP = 10; OcMOVI = 16; OcCMPI = 18; 
  OcMUL = 11; OcDIV = 12; OcMOD = 13; OcADD = 14; OcSUB = 15;
  OcMULI =19; OcADDI = 22; 
  OcLDB = 24; OcLDW = 25; OcSTB = 26; OcSTW = 27; OcPOP = 28; OcPSH = 29;
  OcSYS = 31; OcJUMP = 48; OcCALL = 49;
  OcBEQ = 50; OcBNE = 51; OcBLS = 52; OcBGE = 53; OcBLE = 54; OcBGT = 55;


TYPE


  Gen = RECORD
    mode : INTEGER;
    type : INTEGER;
    size : INTEGER;
    level : INTEGER;
    reg : INTEGER;
    addr1 : INTEGER;
    addr2 : INTEGER;
    cond : INTEGER;
    expConst : BOOLEAN
  END;


VAR

  code : ARRAY 10000 OF INTEGER;
  source : Scanner.Source; (* root module *)
  level : INTEGER; (* level of nested procedures *)
  modules : INTEGER; (* linked list of module symbols *)
  varsize : INTEGER;
  regs : ARRAY RegGP OF BOOLEAN;
  pc : INTEGER; (* program counter *)
  entrypoint : INTEGER;


(* generator *)


PROCEDURE GenInitRegs;

  VAR i : INTEGER;

  BEGIN
    i := 0;
    WHILE i < RegGP DO
      regs[i] := FALSE; i := i + 1
    END
  END GenInitRegs;


PROCEDURE GenAllocReg(VAR s : Scanner.Source; VAR r : INTEGER);

  VAR r2 : INTEGER;

  BEGIN
    r := -1; r2 := 0;
    WHILE r2 < RegGP DO
      IF regs[r2] THEN
        r2 := r2 + 1
      ELSE
        r := r2;
        regs[r] := TRUE;
        r2 := RegGP
      END
    END;
    IF r = -1 THEN
      Scanner.RaiseError(s, Base.ErrOutOfRegs)
    END
  END GenAllocReg;


PROCEDURE GenFreeReg(r : INTEGER);

  BEGIN
    IF r < RegGP THEN
      regs[r] := FALSE
    END
  END GenFreeReg;


PROCEDURE GenCheckRegs(VAR s : Scanner.Source);

  VAR r : INTEGER;

  BEGIN
    r := 0;
    WHILE r < RegGP DO
      IF regs[r] THEN
        Scanner.RaiseError(s, Base.ErrCheckRegs)
      END;
      r := r + 1
    END
  END GenCheckRegs;


PROCEDURE GenAlign(VAR size : INTEGER);

  VAR i : INTEGER; j : INTEGER;

  BEGIN
    IF size < 0 THEN i := -4 ELSE i := 4 END;
    j := size MOD i;
    IF j # 0 THEN
      size := size + (i - j)
    END
  END GenAlign;


PROCEDURE GenEmit(instr : INTEGER);

  BEGIN
    code[pc] := instr; pc := pc + 1
  END GenEmit;


PROCEDURE GenEmitOc1(oc : INTEGER; c : INTEGER);

  BEGIN
    GenEmit(oc + c * 64)
  END GenEmitOc1;


PROCEDURE GenEmitOc3(oc : INTEGER; a : INTEGER; b : INTEGER; c : INTEGER);

  BEGIN
    IF (c >= -20000H) & (c < 20000H) THEN
      GenEmit(oc + a * 64 + b * 1024 + c * 16384)
    ELSE
      GenEmit(oc + 16 + a * 64 + b * 1024);
      GenEmit(c)
    END
  END GenEmitOc3;


PROCEDURE GenFixLink(l : INTEGER);

  VAR l2 : INTEGER;

  BEGIN
    WHILE l # 0 DO
      l2 := code[l];
      code[l] := l2 MOD 64 + 64 * (pc - l - 1);
      l := l2 DIV 64
    END
  END GenFixLink;


PROCEDURE GenMergeLinks(VAR l : INTEGER ; l2 : INTEGER);

  VAR l3 : INTEGER; l4 : INTEGER; l5 : INTEGER; continue : BOOLEAN;

  BEGIN
    IF l2 # 0 THEN
      l3 := l2;
      continue := TRUE;
      WHILE continue DO
        code[l3] := l4;
        l5 := l4 DIV 64;
        IF l5 = 0 THEN
          continue := FALSE
        ELSE
          l3 := l5
        END
      END;
      code[l3] := l4 + 64 * l;
      l := l2
    END
  END GenMergeLinks;


PROCEDURE GenNegCond(VAR c : INTEGER);

  BEGIN
    IF c = Scanner.TokEq THEN c := Scanner.TokEqN
    ELSIF c = Scanner.TokEqN THEN c := Scanner.TokEq
    ELSIF c = Scanner.TokLss THEN c := Scanner.TokGEq
    ELSIF c = Scanner.TokGEq THEN c := Scanner.TokLss
    ELSIF c = Scanner.TokLEq THEN c := Scanner.TokGtr
    ELSIF c = Scanner.TokGtr THEN c := Scanner.TokLEq
    END
  END GenNegCond;


PROCEDURE GenEmitCondBR(cond : INTEGER; disp : INTEGER; negated : BOOLEAN);

  VAR oc : INTEGER;

  BEGIN
    IF negated THEN GenNegCond(cond) END;
    IF cond = Scanner.TokEq THEN oc := OcBEQ
    ELSIF cond = Scanner.TokEqN THEN oc := OcBNE
    ELSIF cond = Scanner.TokLss THEN oc := OcBLS
    ELSIF cond = Scanner.TokGEq THEN oc := OcBGE
    ELSIF cond = Scanner.TokLEq THEN oc := OcBLE
    ELSIF cond = Scanner.TokGtr THEN oc := OcBGT
    END;
    GenEmitOc1(oc, disp)
  END GenEmitCondBR;


PROCEDURE GenBCall(l : INTEGER);

  BEGIN
    GenEmitOc1(OcCALL, -l - pc - 1)
  END GenBCall;


PROCEDURE GenFCall(VAR l : INTEGER);

  BEGIN
    GenEmitOc1(OcCALL, -l);
    l := -(pc - 1)
  END GenFCall;


PROCEDURE GenBJump(l : INTEGER);

  BEGIN
    GenEmitOc1(OcJUMP, l - pc - 1)
  END GenBJump;


PROCEDURE GenFJump(VAR l : INTEGER);

  BEGIN
    GenEmitOc1(OcJUMP, l);
    l := pc - 1
  END GenFJump;


PROCEDURE GenEnter(varsize : INTEGER);

  BEGIN
    GenEmitOc3(OcPSH, RegRT, RegSP, -4);
    GenEmitOc3(OcPSH, RegFP, RegSP, -4);
    GenEmitOc3(OcMOV, RegFP, 0, RegSP);
    IF varsize # 0 THEN
      GenEmitOc3(OcADDI, RegSP, RegSP, varsize)
    END
  END GenEnter;


PROCEDURE GenReturn(parsize : INTEGER);

  BEGIN
    GenEmitOc3(OcMOV, RegSP, 0, RegFP);
    GenEmitOc3(OcPOP, RegFP, RegSP, 4);
    GenEmitOc3(OcPOP, RegPC, RegSP, 4 + parsize)
  END GenReturn;


PROCEDURE GenMake(VAR s : Scanner.Source; VAR g : Gen;
                  VAR y : STable.Symbol);

  VAR r : INTEGER;

  BEGIN
    g.mode := y.class;
    g.type := y.type;
    g.size := STable.types[y.type].size;
    g.level := y.level;
    g.addr1 := y.value;
    g.addr2 := y.value2;
    IF g.level = 0 THEN
      g.reg := RegGP
    ELSE
      g.reg := RegFP
    END;
    WHILE g.addr2 > 0 DO
      GenAllocReg(s, r);
      GenEmitOc3(OcLDW, r, g.reg, g.addr1);
      GenFreeReg(g.reg);
      g.reg := r;
      g.addr1 := 0; (* --> GenParam, GenAddr *)
      g.addr2 := g.addr2 - 1
    END
  END GenMake;


PROCEDURE GenLoad(VAR s : Scanner.Source; VAR g : Gen);

  VAR r : INTEGER;

  BEGIN
    IF g.mode # ModeReg THEN
      IF g.mode = STable.ClassConst THEN
        GenAllocReg(s, g.reg);
        GenEmitOc3(OcMOVI, g.reg, 0, g.addr1)
      ELSIF g.mode = STable.ClassVar THEN
        GenAllocReg(s, r);
        IF g.size = 1 THEN
          GenEmitOc3(OcLDB, r, g.reg, g.addr1)
        ELSE
          GenEmitOc3(OcLDW, r, g.reg, g.addr1)
        END;
        GenFreeReg(g.reg);
        g.reg := r
      ELSIF g.mode = ModeCond THEN
        GenEmitCondBR(g.cond, 2, TRUE);
        GenFreeReg(g.reg);
        GenFixLink(g.addr2);
        GenAllocReg(s, g.reg);
        GenEmitOc3(OcMOVI, g.reg, 0, 1);
        GenEmitOc1(OcJUMP, 1);
        GenFixLink(g.addr1);
        GenEmitOc3(OcMOVI, g.reg, 0, 0)
      END;
      g.mode := ModeReg
    END
  END GenLoad;


PROCEDURE GenLoadCond(VAR s : Scanner.Source; VAR g : Gen);

  BEGIN
    IF g.mode # ModeCond THEN
      GenLoad(s, g);
      GenEmitOc3(OcCMPI, g.reg, g.reg, 0);
      GenFreeReg(g.reg); GenCheckRegs(s);
      g.mode := ModeCond;
      g.addr1 := 0;
      g.addr2 := 0;
      g.cond := Scanner.TokEqN
    END
  END GenLoadCond;


PROCEDURE GenCondFJump(VAR s : Scanner.Source; VAR g : Gen);

  BEGIN
    GenLoadCond(s, g);
    GenEmitCondBR(g.cond, g.addr1, TRUE);
    GenFreeReg(g.reg);
    GenFixLink(g.addr2);
    g.addr1 := pc - 1;
    GenCheckRegs(s)
  END GenCondFJump;


PROCEDURE GenStore(VAR s : Scanner.Source; VAR g : Gen; VAR g2 : Gen);

  BEGIN
    GenLoad(s, g2);
    IF g.size = 1 THEN
      GenEmitOc3(OcSTB, g2.reg, g.reg, g.addr1)
    ELSE
      GenEmitOc3(OcSTW, g2.reg, g.reg, g.addr1)
    END;
    GenFreeReg(g2.reg); GenFreeReg(g.reg); GenCheckRegs(s)
  END GenStore;


PROCEDURE GenParam(VAR s : Scanner.Source; VAR g : Gen; isRef : BOOLEAN);

  VAR r : INTEGER;

  BEGIN
    IF isRef THEN (* ref param *)
      IF g.mode = STable.ClassVar THEN
        IF g.addr1 = 0 (* -->GenMake *) THEN
          r := g.reg
        ELSE
          GenAllocReg(s, r);
          GenEmitOc3(OcADDI, r, g.reg, g.addr1);
          GenFreeReg(g.reg)
        END;
        GenEmitOc3(OcPSH, r, RegSP, -4);
        GenFreeReg(r)
      ELSE
        Scanner.RaiseError(s, Base.ErrNotLValue)
      END
    ELSE (* value param *)
      GenLoad(s, g);
      GenEmitOc3(OcPSH, g.reg, RegSP, -4)
    END;
    GenFreeReg(g.reg); GenCheckRegs(s)
  END GenParam;


PROCEDURE GenField(VAR g : Gen; VAR y : STable.Symbol);

  BEGIN
    g.addr1 := g.addr1 + y.value
  END GenField;


PROCEDURE GenIndex(VAR s : Scanner.Source; VAR g : Gen; VAR g2 : Gen);

  VAR size : INTEGER;

  BEGIN
    size := STable.types[STable.types[g.type].value].size;
    IF g2.mode = STable.ClassConst THEN
      IF (g2.addr1 >= 0) &
         (g2.addr1 < STable.types[g.type].len) THEN
        g.addr1 := g.addr1 + g2.addr1 * size
      ELSE
        Scanner.RaiseError(s, Base.ErrBadIndex)
      END
    ELSE
      GenLoad(s, g2);
      IF size > 1 THEN
        GenEmitOc3(OcMULI, g2.reg, g2.reg, size)
      END;
      GenEmitOc3(OcADD, g2.reg, g2.reg, g.reg);
      GenFreeReg(g.reg);
      g.reg := g2.reg
    END
  END GenIndex;


PROCEDURE GenOp(VAR s : Scanner.Source; op : INTEGER; VAR g : Gen; VAR g2 : Gen);

  BEGIN
    GenLoad(s, g);
    IF g2.mode = STable.ClassConst THEN
      GenEmitOc3(op + 8, g.reg, g.reg, g2.addr1)
    ELSE
      GenLoad(s, g2);
      GenEmitOc3(op, g.reg, g.reg, g2.reg);
      GenFreeReg(g2.reg)
    END
  END GenOp;


PROCEDURE GenOp1(VAR s : Scanner.Source; VAR g : Gen; op : INTEGER);

  VAR l : INTEGER;

  BEGIN
    IF op = Scanner.TokMinus THEN
      IF g.mode = STable.ClassVar THEN
        GenLoad(s, g)
      END;
      GenEmitOc3(OcMVN, g.reg, 0, g.reg)
    ELSIF op = Scanner.TokTilde THEN
      IF g.mode = STable.ClassConst THEN
        IF g.addr1 = 1 THEN g.addr1 := 0 ELSE g.addr1 := 1 END
      ELSE
        GenLoadCond(s, g); GenNegCond(g.cond);
        l := g.addr1; g.addr1 := g.addr2; g.addr2 := l
      END
    ELSIF op = Scanner.TokAmper THEN
      GenLoadCond(s, g);
      GenEmitCondBR(g.cond, g.addr1, TRUE);
      GenFreeReg(g.reg);
      g.addr1 := pc - 1;
      GenFixLink(g.addr2);
      g.addr2 := 0
    ELSIF op = Scanner.TokOr THEN
      GenLoadCond(s, g);
      GenEmitCondBR(g.cond, g.addr2, FALSE);
      GenFreeReg(g.reg);
      g.addr2 := pc - 1;
      GenFixLink(g.addr1);
      g.addr1 := 0
    END
  END GenOp1;


PROCEDURE GenOp2(VAR s : Scanner.Source; VAR g : Gen; VAR g2 : Gen; op : INTEGER);

  BEGIN
    IF STable.types[g.type].form = STable.FormInt THEN
      IF op = Scanner.TokAsterisk THEN GenOp(s, OcMUL, g, g2)
      ELSIF op = Scanner.TokDiv THEN GenOp(s, OcDIV, g, g2)
      ELSIF op = Scanner.TokMod THEN GenOp(s, OcMOD, g, g2)
      ELSIF op = Scanner.TokPlus THEN GenOp(s, OcADD, g, g2)
      ELSIF op = Scanner.TokMinus THEN GenOp(s, OcSUB, g, g2)
      END
    ELSE (* STable.FormBool *)
      IF (g.mode = STable.ClassConst) & (g2.mode = STable.ClassConst) THEN
        IF op = Scanner.TokOr THEN
          IF (g.addr1 = 1) OR (g2.addr1 = 1) THEN
            g.addr1 := 1
          ELSE
            g.addr1 := 0
          END
        ELSE (* Scanner.TokAmper *)
          IF (g.addr1 = 1) & (g2.addr1 = 1) THEN
            g.addr1 := 1
          ELSE
            g.addr1 := 0
          END
        END
      ELSE
        GenLoadCond(s, g2);
        IF op = Scanner.TokOr THEN
          g.addr1 := g2.addr1;
          GenMergeLinks(g.addr2, g2.addr2)
        ELSE (* Scanner.TokAmper *)
          GenMergeLinks(g.addr1, g2.addr1);
          g.addr2 := g2.addr2
        END;
        g.cond := g2.cond
      END
    END
  END GenOp2;


PROCEDURE GenRel(VAR s : Scanner.Source; VAR g : Gen; VAR g2 : Gen; op : INTEGER);

  BEGIN
    GenOp(s, OcCMP, g, g2);
    g.cond := op;
    g.mode := ModeCond;
    g.addr1 := 0;
    g.addr2 := 0;
    GenFreeReg(g.reg); GenCheckRegs(s)
  END GenRel;


PROCEDURE GenSys(VAR s : Scanner.Source; call : INTEGER; VAR g : Gen; VAR g2 : Gen);

  VAR r : INTEGER;

  BEGIN
    GenLoad(s, g2);
    GenAllocReg(s, r);
    GenEmitOc3(OcSYS, r, g2.reg, call);
    GenEmitOc3(OcSTW, r, g.reg, g.addr1);
    GenFreeReg(r);
    GenFreeReg(g.reg);
    GenFreeReg(g2.reg)
  END GenSys;


PROCEDURE GenAddr(VAR s : Scanner.Source; VAR g : Gen);

  VAR r : INTEGER;

  BEGIN
    IF g.mode = STable.ClassVar THEN
      IF g.addr1 # 0 (* -->GenMake *) THEN
        GenAllocReg(s, r);
        GenEmitOc3(OcADDI, r, g.reg, g.addr1);
        GenFreeReg(g.reg);
        g.reg := r
      END;
      g.mode := ModeReg
    ELSE
      Scanner.RaiseError(s, Base.ErrNotLValue)
    END
  END GenAddr;


PROCEDURE GenCreateFile;

  CONST FileOpenModeWrite = 2;

  VAR filename : INTEGER; file : INTEGER; n : INTEGER;

  BEGIN
    Sys.GetArg(filename, 1);
    Sys.OpenFile(file, filename, FileOpenModeWrite);
    Sys.WriteFile(n, file, ADDR(code), pc * 4);
    Sys.CloseFile(file)
  END GenCreateFile;


(* parser *)


PROCEDURE parse;

  VAR yModule : INTEGER;


  PROCEDURE accept(VAR s : Scanner.Source; token : INTEGER);

    BEGIN
      IF s.token # token THEN
        IF token = Scanner.TokIdent THEN
          Scanner.RaiseError(s, Base.ErrIdentExp)
        ELSIF token = Scanner.TokInt THEN
          Scanner.RaiseError(s, Base.ErrIntExp)
        ELSIF token = Scanner.TokChar THEN
          Scanner.RaiseError(s, Base.ErrCharExp)
        ELSE
          Scanner.RaiseError(s, token)
        END
      END
    END accept;


  PROCEDURE checkBool(VAR s : Scanner.Source; VAR g : Gen);

    BEGIN
      IF STable.types[g.type].form # STable.FormBool THEN
        Scanner.RaiseError(s, Base.ErrBoolExp)
      END
    END checkBool;


  PROCEDURE checkChar(VAR s : Scanner.Source; VAR g : Gen);

    BEGIN
      IF STable.types[g.type].form # STable.FormChar THEN
        Scanner.RaiseError(s, Base.ErrCharExp)
      END
    END checkChar;


  PROCEDURE checkInt(VAR s : Scanner.Source; VAR g : Gen);

    BEGIN
      IF STable.types[g.type].form # STable.FormInt THEN
        Scanner.RaiseError(s, Base.ErrIntExp)
      END
    END checkInt;


  PROCEDURE identDef(VAR s : Scanner.Source; VAR y : INTEGER;
                     class : INTEGER);

    BEGIN
      accept(s, Scanner.TokIdent);
      STable.CopyIdent(STable.symbols[STable.Marker].name, s.ident);
      STable.FindSymbol(y, STable.topScope);
      IF STable.symbols[y].next = STable.Marker THEN
        STable.AllocSymbol(s, class, level);
        STable.SymbolNext(y, STable.allocSymbol);
        y := STable.allocSymbol;
        Scanner.Next(s);
        IF s.token = Scanner.TokAsterisk THEN
          STable.SymbolPublic(y); Scanner.Next(s)
        END
      ELSE
        Scanner.RaiseError(s, Base.ErrMultipleDef)
      END
    END identDef;


  PROCEDURE identUse(VAR s : Scanner.Source; VAR y : INTEGER);


    PROCEDURE checkLevel(VAR s : Scanner.Source; VAR y : STable.Symbol);

      BEGIN
        IF (y.level # 0) &
           (y.level # level) &
           (y.class = STable.ClassVar) THEN
          Scanner.RaiseError(s, Base.ErrIdentUndef)
        END
      END checkLevel;


    PROCEDURE search(VAR s : Scanner.Source; VAR y : INTEGER;
                     scope : INTEGER; VAR ident : Scanner.Ident);

      BEGIN
        STable.CopyIdent(STable.symbols[STable.Marker].name, ident);
        WHILE scope # -1 DO
          STable.FindSymbol(y, scope);
          IF STable.symbols[y].next # STable.Marker THEN
            scope := -1
          ELSE
            scope := STable.symbols[scope].scope
          END
        END;
        IF STable.symbols[y].next # STable.Marker THEN
          y := STable.symbols[y].next
        ELSE
          Scanner.RaiseError(s, Base.ErrIdentUndef)
        END
      END search;


    BEGIN (* identUse *)
      search(s, y, STable.topScope, s.ident);
      IF STable.symbols[y].class = STable.ClassQual THEN
        Scanner.Next(s); accept(s, Scanner.TokDot); 
        Scanner.Next(s); accept(s, Scanner.TokIdent); 
        search(s, y, STable.symbols[y].value, s.ident)
      END;
      checkLevel(s, STable.symbols[y])
    END identUse;


  PROCEDURE expr(VAR s : Scanner.Source; VAR g : Gen);

    VAR op : INTEGER; g2 : Gen;


    PROCEDURE Op1(VAR s : Scanner.Source; VAR g : Gen; op : INTEGER);

      BEGIN
        IF op = Scanner.TokMinus THEN
          IF g.mode = STable.ClassConst THEN
            IF g.addr1 # Sys.MinInt THEN
              g.addr1 := -g.addr1
            ELSE
              Scanner.RaiseError(s, Base.ErrIntOverflow)
            END
          ELSE
            GenOp1(s, g, op)
          END
        END
      END Op1;


    PROCEDURE Op2(VAR s : Scanner.Source; VAR g : Gen; VAR g2 : Gen; op : INTEGER);


      PROCEDURE mul(VAR s : Scanner.Source; VAR g : Gen; VAR g2 : Gen);

        VAR isNeg : BOOLEAN; i : INTEGER;

        BEGIN
          IF (g.addr1 = 0) OR (g2.addr1 = 0) THEN
            g.addr1 := 0
          ELSE
            IF (g.addr1 > 0) & (g2.addr1 < 0) OR
               (g.addr1 < 0) & (g2.addr1 > 0) THEN
              isNeg := TRUE;
              i := Sys.MinInt
            ELSE
              isNeg := FALSE;
              i := Sys.MaxInt
            END;
            i := i DIV g2.addr1;
            IF (g.addr1 < 0) & (i > g.addr1) OR
               (g.addr1 > 0) & (i < g.addr1) THEN
              Scanner.RaiseError(s, Base.ErrIntOverflow)
            ELSE
              g.addr1 := g.addr1 * g2.addr1
            END
          END
        END mul;


      PROCEDURE div(VAR s : Scanner.Source; VAR g : Gen; VAR g2 : Gen);

        BEGIN
          IF g2.addr1 = 0 THEN
            Scanner.RaiseError(s, Base.ErrDivZero)
          ELSE
            g.addr1 := g.addr1 DIV g2.addr1
          END
        END div;


      PROCEDURE mod(VAR s : Scanner.Source; VAR g : Gen; VAR g2 : Gen);

        BEGIN
          IF g2.addr1 = 0 THEN
            Scanner.RaiseError(s, Base.ErrDivZero)
          ELSE
            g.addr1 := g.addr1 MOD g2.addr1
          END
        END mod;


      PROCEDURE add(VAR s : Scanner.Source; VAR g : Gen; VAR g2 : Gen);

        BEGIN
          IF Sys.MaxInt - g2.addr1 < g.addr1 THEN
            Scanner.RaiseError(s, Base.ErrIntOverflow)
          ELSE
            g.addr1 := g.addr1 + g2.addr1
          END
        END add;


      PROCEDURE sub(VAR s : Scanner.Source; VAR g : Gen; VAR g2 : Gen);

        BEGIN
          IF Sys.MinInt + g2.addr1 > g.addr1 THEN
            Scanner.RaiseError(s, Base.ErrIntOverflow)
          ELSE
            g.addr1 := g.addr1 - g2.addr1
          END
        END sub;


      BEGIN (* Op2 *)
        IF STable.types[g.type].form = STable.FormInt THEN
          IF (g.mode = STable.ClassConst) & (g2.mode = STable.ClassConst) THEN
            IF op = Scanner.TokAsterisk THEN mul(s, g, g2)
            ELSIF op = Scanner.TokDiv THEN div(s, g, g2)
            ELSIF op = Scanner.TokMod THEN mod(s, g, g2)
            ELSIF op = Scanner.TokPlus THEN add(s, g, g2)
            ELSIF op = Scanner.TokMinus THEN sub(s, g, g2)
            END
          ELSE
            GenOp2(s, g, g2, op)
          END
        ELSE
          GenOp2(s, g, g2, op)
        END
      END Op2;


    PROCEDURE simpleExpr(VAR s : Scanner.Source; VAR g : Gen);

      VAR op : INTEGER; g2 : Gen;


      PROCEDURE term(VAR s : Scanner.Source; VAR g : Gen);

        VAR op : INTEGER; g2 : Gen;


        PROCEDURE factor(VAR s : Scanner.Source; VAR g : Gen);

          VAR y : INTEGER;


          PROCEDURE selector(VAR s : Scanner.Source; VAR g : Gen);

            VAR g2 : Gen; y : INTEGER;

            BEGIN
              WHILE (s.token = Scanner.TokBrackL) OR
                    (s.token = Scanner.TokDot) DO
                IF s.token = Scanner.TokBrackL THEN
                  IF STable.types[g.type].form = STable.FormArray THEN
                    Scanner.Next(s);
                    g2.expConst := FALSE;
                    expr(s, g2);
                    checkInt(s, g2);
                    GenIndex(s, g, g2);
                    accept(s, Scanner.TokBrackR);
                    g.type := STable.types[g.type].value;
                    g.size := STable.types[g.type].size
                  ELSE
                    Scanner.RaiseError(s, Base.ErrArrayExp)
                  END
                ELSE
                  IF STable.types[g.type].form = STable.FormRecord THEN
                    Scanner.Next(s); accept(s, Scanner.TokIdent);
                    STable.CopyIdent(STable.symbols[STable.Marker].name, s.ident);
                    STable.FindSymbol(y, STable.types[g.type].value);
                    y := STable.symbols[y].next;
                    IF y # STable.Marker THEN
                      g.type := STable.symbols[y].type;
                      g.size := STable.types[STable.symbols[y].type].size;
                      GenField(g, STable.symbols[y])
                    ELSE
                      Scanner.RaiseError(s, Base.ErrIdentUndef)
                    END
                  ELSE
                    Scanner.RaiseError(s, Base.ErrRecordExp)
                  END
                END;
                Scanner.Next(s)
              END
            END selector;


          PROCEDURE stdFunc(VAR s : Scanner.Source; VAR g : Gen; VAR y : STable.Symbol);

            BEGIN
              Scanner.Next(s);
              accept(s, Scanner.TokParenL);
              Scanner.Next(s);
              g.expConst := FALSE;
              expr(s, g);
              IF y.value = 1 (* ADDR *) THEN
                GenAddr(s, g);
                g.type := STable.intType
              ELSIF y.value = 2 (* CHR *) THEN
                checkInt(s, g);
                g.type := STable.charType
              ELSIF y.value = 3 (* ORD *) THEN
                checkChar(s, g);
                g.type := STable.intType
              END;
              accept(s, Scanner.TokParenR);
              Scanner.Next(s)
            END stdFunc;


          BEGIN (* factor *)
            IF s.token = Scanner.TokChar THEN
              g.mode := STable.ClassConst;
              g.type := STable.charType;
              g.addr1 := s.value;
              Scanner.Next(s)
            ELSIF s.token = Scanner.TokInt THEN
              g.mode := STable.ClassConst;
              g.type := STable.intType;
              g.addr1 := s.value;
              Scanner.Next(s)
            ELSIF s.token = Scanner.TokFalse THEN
              g.mode := STable.ClassConst;
              g.type := STable.boolType;
              g.addr1 := 0;
              Scanner.Next(s)
            ELSIF s.token = Scanner.TokTrue THEN
              g.mode := STable.ClassConst;
              g.type := STable.boolType;
              g.addr1 := 1;
              Scanner.Next(s)
            ELSIF s.token = Scanner.TokIdent THEN
              identUse(s, y);
              IF STable.symbols[y].class = STable.ClassFunc THEN
                stdFunc(s, g, STable.symbols[y])
              ELSE
                GenMake(s, g, STable.symbols[y]);
                Scanner.Next(s);
                selector(s, g)
              END
            ELSIF s.token = Scanner.TokParenL THEN
              Scanner.Next(s);
              expr(s, g);
              accept(s, Scanner.TokParenR);
              Scanner.Next(s)
            ELSIF s.token = Scanner.TokTilde THEN
              Scanner.Next(s);
              factor(s, g);
              checkBool(s, g);
              GenOp1(s, g, Scanner.TokTilde)
            ELSE
              Scanner.RaiseError(s, Base.ErrFactorExp)
            END
          END factor;


        BEGIN (* term *)
          factor(s, g);
          WHILE (s.token = Scanner.TokAsterisk) OR
                (s.token = Scanner.TokDiv) OR
                (s.token = Scanner.TokMod) OR
                (s.token = Scanner.TokAmper) DO
            op := s.token;
            IF op # Scanner.TokAmper THEN
              checkInt(s, g)
            ELSE
              checkBool(s, g);
              GenOp1(s, g, op)
            END;
            Scanner.Next(s);
            g2.expConst := FALSE;
            factor(s, g2);
            IF g.type = g2.type THEN
              Op2(s, g, g2, op)
            ELSE
              Scanner.RaiseError(s, Base.ErrIncompTypes)
            END
          END
        END term;


      BEGIN (* simpleExpr *)
        IF s.token = Scanner.TokPlus THEN
          Scanner.Next(s);
          term(s, g);
          checkInt(s, g)
        ELSIF s.token = Scanner.TokMinus THEN
          Scanner.Next(s);
          term(s, g);
          checkInt(s, g);
          Op1(s, g, Scanner.TokMinus)
        ELSE
          term(s, g)
        END;
        WHILE (s.token = Scanner.TokPlus) OR
              (s.token = Scanner.TokMinus) OR
              (s.token = Scanner.TokOr) DO
          op := s.token;
          IF op # Scanner.TokOr THEN
            checkInt(s, g)
          ELSE
            checkBool(s, g);
            GenOp1(s, g, op)
          END;
          Scanner.Next(s);
          g2.expConst := FALSE;
          term(s, g2);
          IF g.type = g2.type THEN
            Op2(s, g, g2, op)
          ELSE
            Scanner.RaiseError(s, Base.ErrIncompTypes)
          END
        END
      END simpleExpr;


    BEGIN (* expr *)
      simpleExpr(s, g);
      IF (s.token = Scanner.TokEq) OR (s.token = Scanner.TokEqN) OR
         (s.token = Scanner.TokLss) OR (s.token = Scanner.TokLEq) OR
         (s.token = Scanner.TokGtr) OR (s.token = Scanner.TokGEq) THEN
        IF ~g.expConst THEN
          op := s.token;
          Scanner.Next(s);
          g2.expConst := FALSE;
          simpleExpr(s, g2);
          IF g.type = g2.type THEN
            GenRel(s, g, g2, op);
            g.type := STable.boolType;
            g.size := STable.types[STable.boolType].size
          ELSE
            Scanner.RaiseError(s, Base.ErrIncompTypes)
          END
        ELSE
          Scanner.RaiseError(s, Base.ErrConstExp)
        END
      END
    END expr;


  PROCEDURE constExpr(VAR s : Scanner.Source; VAR i : INTEGER);

    VAR g : Gen;

    BEGIN
      g.expConst := TRUE;
      expr(s, g);
      i := g.addr1
    END constExpr;


  PROCEDURE typeDef(VAR s : Scanner.Source; VAR y : INTEGER; VAR t : INTEGER;
                    class : INTEGER);

    VAR link : INTEGER; y2 : INTEGER;


    PROCEDURE array(VAR s : Scanner.Source; VAR t : INTEGER; link : INTEGER);

      VAR y : INTEGER;

      BEGIN
        Scanner.Next(s);
        STable.AllocType(s, t, STable.FormArray, 0, link);
        constExpr(s, STable.types[t].len);
        accept(s, Scanner.TokOf);
        Scanner.Next(s);
        typeDef(s, y, STable.types[t].value, 0);
        STable.TypeSize(t, STable.types[t].len *
          STable.types[STable.types[t].value].size)
      END array;


    PROCEDURE record(VAR s : Scanner.Source; VAR t : INTEGER; link : INTEGER);

      VAR addr : INTEGER;


      PROCEDURE field(VAR s : Scanner.Source; VAR t : INTEGER; VAR addr : INTEGER);

        VAR y : INTEGER;

        BEGIN
          typeDef(s, y, t, STable.ClassField);
          STable.SymbolValue(y, addr);
          addr := addr + STable.types[t].size;
          GenAlign(addr)
        END field;


      BEGIN (* record *)
        addr := 0;
        STable.AllocSymbol(s, STable.ClassScope, level);
        Scanner.Next(s);
        field(s, t, addr);
        WHILE s.token = Scanner.TokSemic DO
          Scanner.Next(s); field(s, t, addr)
        END;
        accept(s, Scanner.TokEnd);
        STable.AllocType(s, t, STable.FormRecord, 0, link);
        STable.TypeSize(t, addr);
        STable.TypeValue(t, STable.topScope);
        STable.PopTopScope;
        Scanner.Next(s)
      END record;


    BEGIN (* typeDef *)
      link := -1;
      IF class # 0 THEN
        identDef(s, y, class);
        IF class = STable.ClassType THEN
          link := y;
          accept(s, Scanner.TokEq)
        ELSE
          accept(s, Scanner.TokColon)
        END;
        Scanner.Next(s)
      END;
      IF s.token = Scanner.TokIdent THEN
        identUse(s, y2);
        IF (class # 0) & (y = y2) THEN
          Scanner.RaiseError(s, Base.ErrIdentUndef)
        END;
        t := STable.symbols[y2].type;
        Scanner.Next(s)
      ELSIF s.token = Scanner.TokArray THEN
        array(s, t, link)
      ELSIF s.token = Scanner.TokRecord THEN
        record(s, t, link)
      ELSE
        Scanner.RaiseError(s, Base.ErrTypeExp)
      END;
      IF class # 0 THEN
        STable.SymbolType(y, t)
      END
    END typeDef;


  PROCEDURE stmts(VAR s : Scanner.Source);


    PROCEDURE stmt(VAR s : Scanner.Source);

      VAR y : INTEGER;


      PROCEDURE sys(VAR s : Scanner.Source);

        VAR call : INTEGER; g : Gen; g2 : Gen;

        BEGIN
          Scanner.Next(s); accept(s, Scanner.TokParenL);
          Scanner.Next(s); constExpr(s, call);
          accept(s, Scanner.TokComma); Scanner.Next(s);
          g.expConst := FALSE;
          expr(s, g);
          checkInt(s, g);
          IF g.mode = STable.ClassVar THEN
            accept(s, Scanner.TokComma); Scanner.Next(s);
            g2.expConst := FALSE;
            expr(s, g2);
            checkInt(s, g2);
            GenSys(s, call, g, g2);
            accept(s, Scanner.TokParenR); Scanner.Next(s)
          ELSE
            Scanner.RaiseError(s, Base.ErrNotLValue)
          END
        END sys;


      PROCEDURE assign(VAR s : Scanner.Source);

        VAR g : Gen; g2 : Gen;

        BEGIN
          expr(s, g);
          IF g.mode = STable.ClassVar THEN
            accept(s, Scanner.TokAssign); Scanner.Next(s);
            g2.expConst := FALSE;
            expr(s, g2);
            IF g.type = g2.type THEN
              GenStore(s, g, g2)
            ELSE
              Scanner.RaiseError(s, Base.ErrIncompTypes)
            END
          ELSE
            Scanner.RaiseError(s, Base.ErrNotLValue)
          END
        END assign;


      PROCEDURE call(VAR s : Scanner.Source; VAR proc : STable.Symbol);

        VAR y : INTEGER;


        PROCEDURE param(VAR s : Scanner.Source; VAR y : INTEGER);

          VAR g : Gen;

          BEGIN
            g.expConst := FALSE;
            expr(s, g);
            IF (y # STable.Marker) & (STable.symbols[y].value > 0) THEN
              IF STable.symbols[y].type = g.type THEN
                GenParam(s, g, STable.symbols[y].value2 = 1)
              ELSE
                Scanner.RaiseError(s, Base.ErrIncompTypes)
              END
            ELSE
              Scanner.RaiseError(s, Base.ErrParamsTooMany)
            END;
            y := STable.symbols[y].next
          END param;


        BEGIN (* call *)
          y := STable.symbols[proc.scope].next;
          Scanner.Next(s);
          IF s.token = Scanner.TokParenL THEN
            Scanner.Next(s); param(s, y);
            WHILE s.token = Scanner.TokComma DO
              Scanner.Next(s); param(s, y)
            END;
            accept(s, Scanner.TokParenR); Scanner.Next(s)
          END;
          IF (y = STable.Marker) OR (STable.symbols[y].value < 0) THEN
            IF proc.value = Sys.MinInt THEN (* forward call *)
              GenFCall(proc.value2)
            ELSE (* backward call *)
              GenBCall(proc.value)
            END
          ELSE
            Scanner.RaiseError(s, Base.ErrParamsTooFew)
          END
        END call;


      PROCEDURE if(VAR s : Scanner.Source);

        VAR g : Gen; l : INTEGER;

        BEGIN
          Scanner.Next(s);
          g.expConst := FALSE;
          expr(s, g);
          checkBool(s, g);
          GenCondFJump(s, g);
          accept(s, Scanner.TokThen); Scanner.Next(s); stmts(s);
          l := 0;
          WHILE s.token = Scanner.TokElsif DO
            GenFJump(l);
            GenFixLink(g.addr1);
            Scanner.Next(s);
            expr(s, g);
            checkBool(s, g);
            GenCondFJump(s, g);
            accept(s, Scanner.TokThen); Scanner.Next(s); stmts(s)
          END;
          IF s.token = Scanner.TokElse THEN
            GenFJump(l);
            GenFixLink(g.addr1);
            Scanner.Next(s); stmts(s)
          ELSE
            GenFixLink(g.addr1)
          END;
          GenFixLink(l);
          accept(s, Scanner.TokEnd); Scanner.Next(s)
        END if;


      PROCEDURE while(VAR s : Scanner.Source);

        VAR g : Gen; l : INTEGER;

        BEGIN
          Scanner.Next(s);
          l := pc;
          g.expConst := FALSE;
          expr(s, g);
          checkBool(s, g);
          GenCondFJump(s, g);
          accept(s, Scanner.TokDo);
          Scanner.Next(s); stmts(s);
          GenBJump(l);
          GenFixLink(g.addr1);
          accept(s, Scanner.TokEnd); Scanner.Next(s)
        END while;


      BEGIN (* stmt *)
        IF s.token = Scanner.TokIdent THEN
          identUse(s, y);
          IF STable.symbols[y].class = STable.ClassProc THEN
            call(s, STable.symbols[y])
          ELSE
            assign(s)
          END
        ELSIF s.token = Scanner.TokSys THEN
          sys(s)
        ELSIF s.token = Scanner.TokIf THEN
          if(s)
        ELSIF s.token = Scanner.TokWhile THEN
          while(s)
        ELSE
          Scanner.RaiseError(s, Base.ErrStmtExp)
        END;
        GenCheckRegs(s)
      END stmt;


    BEGIN (* stmts *)
      stmt(s);
      WHILE s.token = Scanner.TokSemic DO
        Scanner.Next(s); stmt(s)
      END
    END stmts;


  PROCEDURE decls(VAR s : Scanner.Source; VAR addr : INTEGER);


    PROCEDURE const(VAR s : Scanner.Source);

      VAR y : INTEGER;

      BEGIN
        WHILE s.token = Scanner.TokIdent DO
          identDef(s, y, STable.ClassConst); accept(s, Scanner.TokEq);
          Scanner.Next(s); constExpr(s, STable.symbols[y].value);
          STable.SymbolType(y, STable.intType);
          accept(s, Scanner.TokSemic);
          Scanner.Next(s)
        END
      END const;


    PROCEDURE type(VAR s : Scanner.Source);

      VAR y : INTEGER; t : INTEGER;

      BEGIN
        WHILE s.token = Scanner.TokIdent DO
          typeDef(s, y, t, STable.ClassType);
          accept(s, Scanner.TokSemic); Scanner.Next(s)
        END
      END type;


    PROCEDURE var(VAR s : Scanner.Source; VAR addr : INTEGER);

      VAR y : INTEGER; t : INTEGER; size : INTEGER;

      BEGIN
        WHILE s.token = Scanner.TokIdent DO
          typeDef(s, y, t, STable.ClassVar);
          size := STable.types[t].size;
          GenAlign(size);
          addr := addr - size;
          STable.SymbolValue(y, addr);
          accept(s, Scanner.TokSemic); Scanner.Next(s)
        END
      END var;


    PROCEDURE proc(VAR s : Scanner.Source);

      VAR

        y : INTEGER; parsize : INTEGER; varsize : INTEGER;
        lastParam : INTEGER; eq : BOOLEAN;


      PROCEDURE params(VAR s : Scanner.Source; VAR addr : INTEGER);

        VAR y : INTEGER; t : INTEGER; offs : INTEGER;

        BEGIN
          IF s.token = Scanner.TokVar THEN
            Scanner.Next(s);
            typeDef(s, y, t, STable.ClassVar);
            STable.SymbolValue2(y, 1)
          ELSE
            typeDef(s, y, t, STable.ClassVar);
            STable.SymbolValue2(y, 0)
          END;
          IF STable.symbols[y].value2 = 0 THEN
            IF STable.types[t].form >= STable.FormArray THEN
              Scanner.RaiseError(s, Base.ErrScalarExp)
            END
          END;
          addr := addr + 4; offs := addr;
          IF s.token = Scanner.TokSemic THEN
            Scanner.Next(s); params(s, addr)
          END;
          STable.SymbolValue(y, addr - offs + 8)
        END params;


      BEGIN (* proc *)
        identDef(s, y, STable.ClassProc);
        STable.SymbolValue(y, Sys.MinInt) (* forward call marker *);
        STable.SymbolValue2(y, 0);
        level := level + 1;
        STable.AllocSymbol(s, STable.ClassScope, level);
        STable.SymbolScope(y, STable.allocSymbol);
        parsize := 0;
        IF s.token = Scanner.TokParenL THEN
          Scanner.Next(s);
          IF s.token # Scanner.TokParenR THEN
            params(s, parsize); accept(s, Scanner.TokParenR); Scanner.Next(s)
          END
        END;
        accept(s, Scanner.TokSemic); Scanner.Next(s);
        lastParam := STable.allocSymbol;
        varsize := 0;
        decls(s, varsize);
        IF STable.symbols[y].value = Sys.MinInt THEN
          GenFixLink(-STable.symbols[y].value2)
        END;
        STable.SymbolValue(y, -pc);
        GenEnter(varsize);
        accept(s, Scanner.TokBegin); Scanner.Next(s); stmts(s);
        accept(s, Scanner.TokEnd); Scanner.Next(s); accept(s, Scanner.TokIdent);
        STable.CompIdent(eq, STable.symbols[y].name, s.ident);
        IF eq THEN
          Scanner.Next(s); accept(s, Scanner.TokSemic); Scanner.Next(s)
        ELSE
          Scanner.RaiseError(s, Base.ErrNameMismatch)
        END;
        IF STable.symbols[lastParam].next # STable.Marker THEN
          STable.DeallocScope(STable.symbols[lastParam].next, FALSE);
          STable.SymbolNext(lastParam, STable.Marker)
        END;
        GenReturn(parsize);
        STable.PopTopScope;
        level := level - 1
      END proc;


    BEGIN (* decls *)
      IF s.token = Scanner.TokConst THEN
        Scanner.Next(s); const(s)
      END;
      IF s.token = Scanner.TokType THEN
        Scanner.Next(s); type(s)
      END;
      IF s.token = Scanner.TokVar THEN
        Scanner.Next(s); var(s, addr)
      END;
      WHILE s.token = Scanner.TokProcedure DO
        Scanner.Next(s); proc(s)
      END
    END decls;


  PROCEDURE module(VAR s : Scanner.Source; VAR yModule : INTEGER);

    VAR eq : BOOLEAN;


    PROCEDURE imports(VAR s : Scanner.Source);


      PROCEDURE loadModule(VAR s : Scanner.Source; VAR yModule : INTEGER;
                           VAR name : Scanner.Ident);

        VAR
          sNew : Scanner.Source; i : INTEGER;
          fn : ARRAY Scanner.MaxLenIdent + 4 OF CHAR;


        PROCEDURE checkCyclcImport(VAR s : Scanner.Source; VAR yModule : INTEGER;
                                   VAR checkee : Scanner.Ident);

          VAR eq : BOOLEAN;

          BEGIN
            yModule := modules; eq := FALSE;
            WHILE (yModule # 0) & ~eq DO
              STable.CompIdent(eq, STable.symbols[yModule].name, checkee);
              IF ~eq THEN
                yModule := STable.symbols[yModule].value2
              END
            END;
            IF eq & (STable.symbols[yModule].value = 0) THEN
              Scanner.RaiseError(s, Base.ErrCyclicImports)
            END
          END checkCyclcImport;


        BEGIN (* loadModule *)
          checkCyclcImport(s, yModule, name);
          IF yModule = 0 THEN
            i := 0;
            WHILE i < name.len DO
              fn[i] := name.data[i]; i := i + 1
            END;
            fn[i] := 2EX; fn[i + 1] := 6EX; fn[i + 2] := 70X; fn[i + 3] := 0X;
            STable.CopyIdent(sNew.name, name);
            Scanner.OpenSource(sNew, ADDR(fn));
            IF sNew.file = 0 THEN
              Scanner.RaiseError(s, Base.ErrOpenFile)
            END;
            module(sNew, yModule)
          END
        END loadModule;


      PROCEDURE import(VAR s : Scanner.Source);

        VAR y : INTEGER; yModule : INTEGER;

        BEGIN
          identDef(s, y, STable.ClassQual);
          STable.SymbolPublic(y);
          IF s.token = Scanner.TokAssign THEN
            Scanner.Next(s); accept(s, Scanner.TokIdent);
            loadModule(s, STable.symbols[y].value, s.ident);
            Scanner.Next(s)
          ELSE
            loadModule(s, STable.symbols[y].value, STable.symbols[y].name)
          END
        END import;


      BEGIN (* imports *)
        import(s);
        WHILE s.token = Scanner.TokComma DO
          Scanner.Next(s); import(s)
        END;
        accept(s, Scanner.TokSemic); Scanner.Next(s)
      END imports;


    BEGIN (* module *)
      Scanner.Next(s); accept(s, Scanner.TokModule);
      Scanner.Next(s); accept(s, Scanner.TokIdent);
      IF source.name.len = 0 THEN
        STable.CopyIdent(s.name, s.ident)
      ELSE
        STable.CompIdent(eq, s.name, s.ident);
        IF ~eq THEN
          Scanner.RaiseError(s, Base.ErrNameMismatch)
        END
      END;
      STable.AllocSymbol(s, STable.ClassScope, level);
      identDef(s, yModule, STable.ClassModule);
      STable.SymbolPublic(yModule);
      STable.SymbolValue2(yModule, modules);
      modules := yModule;
      accept(s, Scanner.TokSemic); Scanner.Next(s);
      IF s.token = Scanner.TokImport THEN
        Scanner.Next(s); imports(s)
      END;
      decls(s, varsize);
      entrypoint := pc;
      IF s.token = Scanner.TokBegin THEN
        IF STable.symbols[yModule].value2 = 0 (* root module *) THEN
          Scanner.Next(s); stmts(s)
        ELSE
          Scanner.RaiseError(s, Base.ErrMainNotAllowed)
        END
      END;
      accept(s, Scanner.TokEnd); Scanner.Next(s); accept(s, Scanner.TokIdent);
      STable.CompIdent(eq, STable.symbols[yModule].name, s.ident);
      IF ~eq THEN
        Scanner.RaiseError(s, Base.ErrNameMismatch)
      END;
      Scanner.Next(s); accept(s, Scanner.TokDot);
      STable.SymbolValue(yModule, 1); (* compiled flag *)
      STable.DeallocScope(STable.topScope, STable.symbols[yModule].value2 # 0);
      STable.PopTopScope
    END module;


  BEGIN (* parse *)
    modules := 0; module(source, yModule)
  END parse;


BEGIN
  level := 0; pc := 0; varsize := 0;
  source.line := 0; source.pos := 0; source.name.len := 0;
  Scanner.OpenSource(source, 0 (* from args *));
  IF source.file = 0 THEN
    Scanner.RaiseError(source, Base.ErrOpenFile)
  END;
  Scanner.Initialize; STable.Initialize;
  STable.AllocSymbol(source, STable.ClassScope, level);
  STable.InitUniverse(source); GenInitRegs; parse;
  STable.DeallocScope(STable.topScope, FALSE) (* universe *);
  Scanner.CloseSource(source);
  GenEmitOc3(OcPOP, RegPC, RegSP, 0);
  GenEmit(varsize); GenEmit(entrypoint * 4);
  GenCreateFile
END NPC01.
